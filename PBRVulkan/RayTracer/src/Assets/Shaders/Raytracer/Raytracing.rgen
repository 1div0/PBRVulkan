#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_NV_ray_tracing : require

#include "../Common/Structs.glsl"
#include "../Common/Random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureNV TLAS;
layout(binding = 1, rgba32f) uniform image2D AccumulationImage;
layout(binding = 2, rgba8) uniform image2D OutputImage;
layout(binding = 3) readonly uniform UniformBufferObject { Uniform ubo; };

layout(location = 0) rayPayloadNV RayPayload Ray;

vec3 tone_map(in vec3 color, float limit)
{
	float luminance = 0.3 * color.x + 0.6 * color.y + 0.1 * color.z;
	return color * 1.0 / (1.0 + luminance / limit);
}

void main() 
{
	mat4 projInv = inverse(ubo.proj);
	mat4 viewInv = inverse(ubo.view);

	uint  rayFlags = gl_RayFlagsOpaqueNV;
	float tMin     = 0.001;
	float tMax     = 10000.0;

	const uint SPP = 5; // Samples per pixel
	vec3 color = vec3(0);
	uint seed = 1; // Updated in rand()

	for (uint i = 0; i < SPP; ++i)
	{
		vec2 pixel = vec2(gl_LaunchIDNV.x + rand(seed), gl_LaunchIDNV.y + rand(seed));
		vec2 uv = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;
		vec4 origin = viewInv * vec4(0, 0, 0, 1);
		vec4 target = projInv * vec4(uv.x, uv.y, 1, 1);
		vec4 direction = viewInv * vec4(normalize(target.xyz), 0);

		Ray.direction = direction.xyz;

		traceNV(TLAS,           // acceleration structure
				rayFlags,       // rayFlags
				0xFF,           // cullMask
				0,              // sbtRecordOffset
				0,              // sbtRecordStride
				0,              // missIndex
				origin.xyz,     // ray origin
				tMin,           // ray min range
				direction.xyz,  // ray direction
				tMax,           // ray max range
				0               // payload (location = 0)
		);

		color += Ray.color;
	}

	color /= SPP;
	color = pow(tone_map(color, 1.5), vec3(1.0 / 2.2));

	imageStore(AccumulationImage, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0));
	imageStore(OutputImage, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0));
}
